{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Pyppium! Pyppium is an Appium-Python-Client wrapper for cross mobile testing. It helps you to save your time by reducing complexity, increasing efficiency and also avoiding these boring and repetitive work problems. Pyppium assists you to focus on what really matters, like your business rules, and provides an environment to start creating your application's screens and your test scenarios as fast as possible. Project Motivation Pyppium has been developed focusing on the cross tests scenarios quality assurance . The most common issues are: A lot of conditionals along the tests. Duplicated screens to isolate the problem above. A BaseScreen or a Helper created to repeat scenarios. How it works Pyppium is based on a technical layer that abstracts some Appium behaviours to help in QA handling. With Pyppium you will see: Screen Object Pattern with abstraction to fetch elements. Cross Mobile Testing focus with some utilities to commons problems. Focus on QA daily problems (like waits), configurations and some boilerplate. Special Thanks Pyppium count on many packages for trying to deliver a good framework. And of course, these packages are amazing! Appium-Python-Client PyYAML Pytest Assertpy Black Pytest-mock Pytest-cov Codecov Mkdocs Tox Mkdocs-material Httpx License The MIT License (MIT) Copyright (c) 2020 Leonardo Menezes Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Welcome to Pyppium!"},{"location":"#welcome-to-pyppium","text":"Pyppium is an Appium-Python-Client wrapper for cross mobile testing. It helps you to save your time by reducing complexity, increasing efficiency and also avoiding these boring and repetitive work problems. Pyppium assists you to focus on what really matters, like your business rules, and provides an environment to start creating your application's screens and your test scenarios as fast as possible.","title":"Welcome to Pyppium!"},{"location":"#project-motivation","text":"Pyppium has been developed focusing on the cross tests scenarios quality assurance . The most common issues are: A lot of conditionals along the tests. Duplicated screens to isolate the problem above. A BaseScreen or a Helper created to repeat scenarios.","title":"Project Motivation"},{"location":"#how-it-works","text":"Pyppium is based on a technical layer that abstracts some Appium behaviours to help in QA handling. With Pyppium you will see: Screen Object Pattern with abstraction to fetch elements. Cross Mobile Testing focus with some utilities to commons problems. Focus on QA daily problems (like waits), configurations and some boilerplate.","title":"How it works"},{"location":"#special-thanks","text":"Pyppium count on many packages for trying to deliver a good framework. And of course, these packages are amazing! Appium-Python-Client PyYAML Pytest Assertpy Black Pytest-mock Pytest-cov Codecov Mkdocs Tox Mkdocs-material Httpx","title":"Special Thanks"},{"location":"#license","text":"The MIT License (MIT) Copyright (c) 2020 Leonardo Menezes Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"browserstack/","text":"Browserstack Pyppium has a pretty easy interface with BrowserStack rest API, you can upload, delete, get an apps list or update a test status. Below has all BrowserStackApi class requests explained, it's easy like Sunday morning! Browserstack Interface Class Browserstack interface is a simple class with some BrowserStack rest requests. You can use with your credentials in the init () like the sample below. BrowserStackApi ( \"my-user\" , \"my-keys\" ) Or you can connect with your environment variables. export BROWSERSTACK_USERNAME=my-user export BROWSERSTACK_ACCESS_KEY=my-keys Warning Remember to use $source command to refresh your terminal session. After exporting your environments variables, you don't need to send parameters with your BrowserStack credentials anymore. The BrowserStackApi class retrieves the user and keys parameters from your local environment. Now you can use BrowserStackApi class without sending any parameters, like the sample below. BrowserStackApi () BrowserStackApi Requests Below has some examples of BrowserStackApi class requests. Getting Recent Apps To get all recently uploaded apps: BrowserStackApi () . recent_uploads () Getting Recent Apps By Custom Id To get all recently uploaded apps with specific custom id : BrowserStackApi () . get_apps_by_custom_id ( \"my-custom-id\" ) Deleting an app by app-id You can delete an app from BrowserStack by app_id : BrowserStackApi () . delete_app ( \"your-app-id\" ) Uploading an app to BrowserStack You can upload your .ipa or .apk to BrowserStack: BrowserStackApi () . upload_app ( \"path/to/my/app\" ) If you want to set a custom id to your app upload: BrowserStackApi () . upload_app ( \"path/to/my/app\" , \"custom_id\" ) Updating test status To update the test status in the Browserstack dashboard: BrowserStackApi () . update_test_status ( session = PyppiumDriver . instance () . session_id , result = \"passed\" , reason = \"No reason, its just a test!\" , ) Manipulating Responses Its easy to manipulate responses from BrowserStackApi class . Below has some examples of getting body content and status code. Getting Body Response To get a response content as a dict its easy, just call json () : body = BrowserStackApi () . recent_uploads () . json () print ( json . dumps ( resp . json (), indent = 4 )) # console output: # [ # { # \"app_name\": \"my-app.ipa\", # \"app_version\": \"4.23.0\", # \"app_url\": \"bs://355e6259172efcdd09c49bae90d7f464e8ca2036\", # \"app_id\": \"355e6259172efcdd09c49bae90d7f464e8ca2036\", # \"uploaded_at\": \"2020-09-03 21:42:33 UTC\" # }, # { # \"app_name\": \"app-debug.apk\", # \"app_version\": \"4.22.1.DEBUG\", # \"app_url\": \"bs://0fb5cfaa3250f666365ab4e812de002bd1ef69ee\", # \"app_id\": \"0fb5cfaa3250f666365ab4e812de002bd1ef69ee\", # \"uploaded_at\": \"2020-09-03 21:07:29 UTC\" # } # ] Getting Status Code Response You can get a status code as an int from response: status = BrowserStackApi () . recent_uploads () . status_code print ( f \"Request status code : { status } \" ) # console output: Request status code : 200 Hint To understand more about httpx Response object you can read the HTTPX Official Documentation .","title":"Browserstack"},{"location":"browserstack/#browserstack","text":"Pyppium has a pretty easy interface with BrowserStack rest API, you can upload, delete, get an apps list or update a test status. Below has all BrowserStackApi class requests explained, it's easy like Sunday morning!","title":"Browserstack"},{"location":"browserstack/#browserstack-interface-class","text":"Browserstack interface is a simple class with some BrowserStack rest requests. You can use with your credentials in the init () like the sample below. BrowserStackApi ( \"my-user\" , \"my-keys\" ) Or you can connect with your environment variables. export BROWSERSTACK_USERNAME=my-user export BROWSERSTACK_ACCESS_KEY=my-keys Warning Remember to use $source command to refresh your terminal session. After exporting your environments variables, you don't need to send parameters with your BrowserStack credentials anymore. The BrowserStackApi class retrieves the user and keys parameters from your local environment. Now you can use BrowserStackApi class without sending any parameters, like the sample below. BrowserStackApi ()","title":"Browserstack Interface Class"},{"location":"browserstack/#browserstackapi-requests","text":"Below has some examples of BrowserStackApi class requests.","title":"BrowserStackApi Requests"},{"location":"browserstack/#getting-recent-apps","text":"To get all recently uploaded apps: BrowserStackApi () . recent_uploads ()","title":"Getting Recent Apps"},{"location":"browserstack/#getting-recent-apps-by-custom-id","text":"To get all recently uploaded apps with specific custom id : BrowserStackApi () . get_apps_by_custom_id ( \"my-custom-id\" )","title":"Getting Recent Apps By Custom Id"},{"location":"browserstack/#deleting-an-app-by-app-id","text":"You can delete an app from BrowserStack by app_id : BrowserStackApi () . delete_app ( \"your-app-id\" )","title":"Deleting an app by app-id"},{"location":"browserstack/#uploading-an-app-to-browserstack","text":"You can upload your .ipa or .apk to BrowserStack: BrowserStackApi () . upload_app ( \"path/to/my/app\" ) If you want to set a custom id to your app upload: BrowserStackApi () . upload_app ( \"path/to/my/app\" , \"custom_id\" )","title":"Uploading an app to BrowserStack"},{"location":"browserstack/#updating-test-status","text":"To update the test status in the Browserstack dashboard: BrowserStackApi () . update_test_status ( session = PyppiumDriver . instance () . session_id , result = \"passed\" , reason = \"No reason, its just a test!\" , )","title":"Updating test status"},{"location":"browserstack/#manipulating-responses","text":"Its easy to manipulate responses from BrowserStackApi class . Below has some examples of getting body content and status code.","title":"Manipulating Responses"},{"location":"browserstack/#getting-body-response","text":"To get a response content as a dict its easy, just call json () : body = BrowserStackApi () . recent_uploads () . json () print ( json . dumps ( resp . json (), indent = 4 )) # console output: # [ # { # \"app_name\": \"my-app.ipa\", # \"app_version\": \"4.23.0\", # \"app_url\": \"bs://355e6259172efcdd09c49bae90d7f464e8ca2036\", # \"app_id\": \"355e6259172efcdd09c49bae90d7f464e8ca2036\", # \"uploaded_at\": \"2020-09-03 21:42:33 UTC\" # }, # { # \"app_name\": \"app-debug.apk\", # \"app_version\": \"4.22.1.DEBUG\", # \"app_url\": \"bs://0fb5cfaa3250f666365ab4e812de002bd1ef69ee\", # \"app_id\": \"0fb5cfaa3250f666365ab4e812de002bd1ef69ee\", # \"uploaded_at\": \"2020-09-03 21:07:29 UTC\" # } # ]","title":"Getting Body Response"},{"location":"browserstack/#getting-status-code-response","text":"You can get a status code as an int from response: status = BrowserStackApi () . recent_uploads () . status_code print ( f \"Request status code : { status } \" ) # console output: Request status code : 200 Hint To understand more about httpx Response object you can read the HTTPX Official Documentation .","title":"Getting Status Code Response"},{"location":"decorators/","text":"Decorators The decorator's module has the objective to help in some common cross tests issues. Ignore Decorator Let's check some common issue of the cross-testing when you don't have the same behaviours to the two platforms. Thinking about two login screens in different platforms (Android/iOS) but that flow has the same result to the business because is the same product. For android you have: A EditText for email A EditText for password A Button for sign in CheckBox before sign in For ios you have: A EditText for email A EditText for password A Button for sign in Have a lot of ways to solve this problem, but the decorator ignore try to do this whit some elegance. class LoginScreen : _button_sign_in = fetch ( iOS ( \"id\" , \"buttonSignIn\" ), Android ( \"id\" , \"button\" )) _input_username = fetch ( iOS ( \"id\" , \"inputUserName\" ), Android ( \"id\" , \"username\" )) _input_password = fetch ( iOS ( \"id\" , \"InputPassword\" ), Android ( \"id\" , \"pass\" )) _checkbox = fetch ( android = Android ( \"id\" , \"checkbox\" )) @ignore ( iOS . name ) def click_checkbox ( self ): self . _checkbox . click () def fill_email ( self , email ): self . _input_username . send_keys ( email ) def fill_password ( self , password ): self . _input_password . send_keys ( password ) def click_button_sign_in ( self ): self . _button_sign_in . click () With ignore decorator you just need to send the platform name what you want to ignore . When you run the tests to LoginScreen all tests should be pass because def click_checkbox () will not run for ios. @pytest . mark . parametrize ( \"capabilities\" , [ caps_ios , caps_android ]) def test_login ( capabilities , username , password ): PyppiumDriver ( capabilities ) screen = LoginScreen () screen . fill_email ( username ) screen . fill_password ( password ) screen . click_checkbox () screen . click_button_sign_in () assert username in ScreenTwo () . label_welcome_message ()","title":"Decorators"},{"location":"decorators/#decorators","text":"The decorator's module has the objective to help in some common cross tests issues.","title":"Decorators"},{"location":"decorators/#ignore-decorator","text":"Let's check some common issue of the cross-testing when you don't have the same behaviours to the two platforms. Thinking about two login screens in different platforms (Android/iOS) but that flow has the same result to the business because is the same product. For android you have: A EditText for email A EditText for password A Button for sign in CheckBox before sign in For ios you have: A EditText for email A EditText for password A Button for sign in Have a lot of ways to solve this problem, but the decorator ignore try to do this whit some elegance. class LoginScreen : _button_sign_in = fetch ( iOS ( \"id\" , \"buttonSignIn\" ), Android ( \"id\" , \"button\" )) _input_username = fetch ( iOS ( \"id\" , \"inputUserName\" ), Android ( \"id\" , \"username\" )) _input_password = fetch ( iOS ( \"id\" , \"InputPassword\" ), Android ( \"id\" , \"pass\" )) _checkbox = fetch ( android = Android ( \"id\" , \"checkbox\" )) @ignore ( iOS . name ) def click_checkbox ( self ): self . _checkbox . click () def fill_email ( self , email ): self . _input_username . send_keys ( email ) def fill_password ( self , password ): self . _input_password . send_keys ( password ) def click_button_sign_in ( self ): self . _button_sign_in . click () With ignore decorator you just need to send the platform name what you want to ignore . When you run the tests to LoginScreen all tests should be pass because def click_checkbox () will not run for ios. @pytest . mark . parametrize ( \"capabilities\" , [ caps_ios , caps_android ]) def test_login ( capabilities , username , password ): PyppiumDriver ( capabilities ) screen = LoginScreen () screen . fill_email ( username ) screen . fill_password ( password ) screen . click_checkbox () screen . click_button_sign_in () assert username in ScreenTwo () . label_welcome_message ()","title":"Ignore Decorator"},{"location":"fetcher/","text":"Fecther The Pyppium fetcher is a module to search elements by the platform. It contains some behaviours like check the consistency of the queries, waits, timeout to search some element. Basic fetcher usage To find one element to the android and ios platform, inside of your screen. class MyScreen : _button = fetch ( iOS ( \"xpath\" , \"//XCUIElementTypeWindow[1]/XCUIElementTypeOther[1]\" ), Android ( \"id\" , \"my_button\" )) This sample above its a simple association of _button to the fetch class. The class Android and iOS only will check if you using a valid locator, before running the tests. If you don't want to use string as the locator you can use the By class from the selenium, just import it. class MyScreen : _button = fetch ( iOS ( By . XPATH , \"//XCUIElementTypeWindow[1]/XCUIElementTypeButton\" ), Android ( By . ID , \"my_button\" )) To fetch a list of elements you can use fetches from fetcher module . class MyScreen : _my_labels_list = fetches ( iOS ( By . XPATH , \"//XCUIElementTypeStaticText\" ), Android ( By . ID , \"my_text_view\" )) Warning Always try to use ids instead of XPath because ids make your tests more consistent and fast. The order of parameters matters, the first parameter is iOS class and second is Android class . But if you don't want to send Android parameter, don't have any problem since you don't run tests with an android capability. class MyScreen : _my_labels_list = fetches ( iOS ( By . XPATH , \"//XCUIElementTypeStaticText\" )) You can run only for android with named parameter. class MyScreen : _my_labels_list = fetches ( android = Android ( By . ID , \"my_text_view\" )) Timeouts Every fetch has a timeout and the default timeout is 15 seconds. You can override the fetch timeout like this sample below. class MyScreen : _button = fetch ( iOS ( \"xpath\" , \"//XCUIElementTypeOther[1]\" ), Android ( \"id\" , \"my_button\" ), timeout = 20 ) Waits The fetcher has a default wait to every fetch. To the fetch class the default wait is wait_visibility_of_element and for the fetches class the default is wit_visibility_of_elements . You can override the wait function sending the constant with the value of wait from conditions module. class MyScreen : _button = fetch ( iOS ( \"xpath\" , \"//XCUIElementTypeOther[1]\" ), Android ( \"id\" , \"my_button\" ), wait_condition = PRESENCE ) Have some possibilities of wait in the condition module below have the condition and a little description. fetch condition . VISIBILITY : Wait for an element to be visible. condition . PRESENCE : Wait for the presence of the element. fetches condition . VISIBILITIES : Wait for the visibility of some elements. condition . VISIBILITY_OF_ANYS : Wait for visibility of any elements.","title":"Fecther"},{"location":"fetcher/#fecther","text":"The Pyppium fetcher is a module to search elements by the platform. It contains some behaviours like check the consistency of the queries, waits, timeout to search some element.","title":"Fecther"},{"location":"fetcher/#basic-fetcher-usage","text":"To find one element to the android and ios platform, inside of your screen. class MyScreen : _button = fetch ( iOS ( \"xpath\" , \"//XCUIElementTypeWindow[1]/XCUIElementTypeOther[1]\" ), Android ( \"id\" , \"my_button\" )) This sample above its a simple association of _button to the fetch class. The class Android and iOS only will check if you using a valid locator, before running the tests. If you don't want to use string as the locator you can use the By class from the selenium, just import it. class MyScreen : _button = fetch ( iOS ( By . XPATH , \"//XCUIElementTypeWindow[1]/XCUIElementTypeButton\" ), Android ( By . ID , \"my_button\" )) To fetch a list of elements you can use fetches from fetcher module . class MyScreen : _my_labels_list = fetches ( iOS ( By . XPATH , \"//XCUIElementTypeStaticText\" ), Android ( By . ID , \"my_text_view\" )) Warning Always try to use ids instead of XPath because ids make your tests more consistent and fast. The order of parameters matters, the first parameter is iOS class and second is Android class . But if you don't want to send Android parameter, don't have any problem since you don't run tests with an android capability. class MyScreen : _my_labels_list = fetches ( iOS ( By . XPATH , \"//XCUIElementTypeStaticText\" )) You can run only for android with named parameter. class MyScreen : _my_labels_list = fetches ( android = Android ( By . ID , \"my_text_view\" ))","title":"Basic fetcher usage"},{"location":"fetcher/#timeouts","text":"Every fetch has a timeout and the default timeout is 15 seconds. You can override the fetch timeout like this sample below. class MyScreen : _button = fetch ( iOS ( \"xpath\" , \"//XCUIElementTypeOther[1]\" ), Android ( \"id\" , \"my_button\" ), timeout = 20 )","title":"Timeouts"},{"location":"fetcher/#waits","text":"The fetcher has a default wait to every fetch. To the fetch class the default wait is wait_visibility_of_element and for the fetches class the default is wit_visibility_of_elements . You can override the wait function sending the constant with the value of wait from conditions module. class MyScreen : _button = fetch ( iOS ( \"xpath\" , \"//XCUIElementTypeOther[1]\" ), Android ( \"id\" , \"my_button\" ), wait_condition = PRESENCE ) Have some possibilities of wait in the condition module below have the condition and a little description. fetch condition . VISIBILITY : Wait for an element to be visible. condition . PRESENCE : Wait for the presence of the element. fetches condition . VISIBILITIES : Wait for the visibility of some elements. condition . VISIBILITY_OF_ANYS : Wait for visibility of any elements.","title":"Waits"},{"location":"getting-started/","text":"QuickStart The fastest way to start using pyppium is to learn about the basics: Pyppium's fetcher and PyppiumDriver. Basic Usage of Pyppium Driver Create your capabilities as usual. caps_android = { \"platformName\" : \"Android\" , \"automationName\" : \"uiautomator2\" , \"deviceName\" : \"Android Emulator\" , \"appPackage\" : \"com.example.dummy\" , \"appActivity\" : \"MainActivity\" , \"newCommandTimeout\" : 0 , } Import PyppiumDriver and pass the capababilities to PyppiumDriver 's initializer from pyppium.driver import PyppiumDriver PyppiumDriver ( caps_android ) Call driver's quit method after running the tests. PyppiumDriver . quit () Info PyppiumDriver's default url connects to http://localhost:4723/wd/hub , May you wish to override it, pass an URL parameter before the capabilities, as follows: PyppiumDriver(\"http://my-url-here\", caps_android) Basic Usage of Fetcher Structure your screen with fetcher, this sample covers a login screen. from pyppium.fetcher import fetch , iOS , Android class ScreenOne : _button_sign_in = fetch ( iOS ( \"id\" , \"buttonSignIn\" ), Android ( \"id\" , \"button\" )) _input_username = fetch ( iOS ( \"id\" , \"inputUserName\" ), Android ( \"id\" , \"username\" )) _input_password = fetch ( iOS ( \"id\" , \"InputPassword\" ), Android ( \"id\" , \"pass\" )) def login ( self , username , password ): self . _input_username . send_keys ( username ) self . _input_password . send_keys ( password ) self . _button_sign_in . click () The screen below is a welcome screen, presented before login. from pyppium.fetcher import fetch , iOS , Android class ScreenTwo : _label_welcome_message = fetch ( iOS ( \"id\" , \"labelHello\" ), Android ( \"id\" , \"welcome_message\" )) def label_welcome_message ( self ): return self . _label_welcome_message . text Info The fetcher always awaits for elements to become visible. Testing Create your test and use your screens and PyppiumDriver. def test_android_basic_behaviours (): username = \"lully\" password = \"123456789\" caps_android = { \"platformName\" : \"Android\" , \"automationName\" : \"uiautomator2\" , \"deviceName\" : \"Android Emulator\" , \"appPackage\" : \"com.example.dummy\" , \"appActivity\" : \"MainActivity\" , \"newCommandTimeout\" : 0 , } PyppiumDriver ( caps_android ) ScreenOne () . login ( username , password ) assert username in ScreenTwo () . label_welcome_message () PyppiumDriver . quit () Warning The fetcher module searches elements in capabilities by the platform. It only searches for Android or iOS , so if platformName is android , it's looking for the Android element and if it's ios , it's looking for the iOS element.","title":"QuickStart"},{"location":"getting-started/#quickstart","text":"The fastest way to start using pyppium is to learn about the basics: Pyppium's fetcher and PyppiumDriver.","title":"QuickStart"},{"location":"getting-started/#basic-usage-of-pyppium-driver","text":"Create your capabilities as usual. caps_android = { \"platformName\" : \"Android\" , \"automationName\" : \"uiautomator2\" , \"deviceName\" : \"Android Emulator\" , \"appPackage\" : \"com.example.dummy\" , \"appActivity\" : \"MainActivity\" , \"newCommandTimeout\" : 0 , } Import PyppiumDriver and pass the capababilities to PyppiumDriver 's initializer from pyppium.driver import PyppiumDriver PyppiumDriver ( caps_android ) Call driver's quit method after running the tests. PyppiumDriver . quit () Info PyppiumDriver's default url connects to http://localhost:4723/wd/hub , May you wish to override it, pass an URL parameter before the capabilities, as follows: PyppiumDriver(\"http://my-url-here\", caps_android)","title":"Basic Usage of Pyppium Driver"},{"location":"getting-started/#basic-usage-of-fetcher","text":"Structure your screen with fetcher, this sample covers a login screen. from pyppium.fetcher import fetch , iOS , Android class ScreenOne : _button_sign_in = fetch ( iOS ( \"id\" , \"buttonSignIn\" ), Android ( \"id\" , \"button\" )) _input_username = fetch ( iOS ( \"id\" , \"inputUserName\" ), Android ( \"id\" , \"username\" )) _input_password = fetch ( iOS ( \"id\" , \"InputPassword\" ), Android ( \"id\" , \"pass\" )) def login ( self , username , password ): self . _input_username . send_keys ( username ) self . _input_password . send_keys ( password ) self . _button_sign_in . click () The screen below is a welcome screen, presented before login. from pyppium.fetcher import fetch , iOS , Android class ScreenTwo : _label_welcome_message = fetch ( iOS ( \"id\" , \"labelHello\" ), Android ( \"id\" , \"welcome_message\" )) def label_welcome_message ( self ): return self . _label_welcome_message . text Info The fetcher always awaits for elements to become visible.","title":"Basic Usage of Fetcher"},{"location":"getting-started/#testing","text":"Create your test and use your screens and PyppiumDriver. def test_android_basic_behaviours (): username = \"lully\" password = \"123456789\" caps_android = { \"platformName\" : \"Android\" , \"automationName\" : \"uiautomator2\" , \"deviceName\" : \"Android Emulator\" , \"appPackage\" : \"com.example.dummy\" , \"appActivity\" : \"MainActivity\" , \"newCommandTimeout\" : 0 , } PyppiumDriver ( caps_android ) ScreenOne () . login ( username , password ) assert username in ScreenTwo () . label_welcome_message () PyppiumDriver . quit () Warning The fetcher module searches elements in capabilities by the platform. It only searches for Android or iOS , so if platformName is android , it's looking for the Android element and if it's ios , it's looking for the iOS element.","title":"Testing"},{"location":"installation/","text":"Installation Pip You can install Pyppium using pip as usual: pip install pyppium GitHub Or you can directly refer to the repository in GitHub, like samples below. Latest Version pip install git+https://github.com/leomenezessz/pyppium Tagged Version pip install git+https://github.com/leomenezessz/pyppium@v0.1.1","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#pip","text":"You can install Pyppium using pip as usual: pip install pyppium","title":"Pip"},{"location":"installation/#github","text":"Or you can directly refer to the repository in GitHub, like samples below.","title":"GitHub"},{"location":"installation/#latest-version","text":"pip install git+https://github.com/leomenezessz/pyppium","title":"Latest Version"},{"location":"installation/#tagged-version","text":"pip install git+https://github.com/leomenezessz/pyppium@v0.1.1","title":"Tagged Version"},{"location":"pyppium-driver/","text":"Pyppium Driver The Pyppium driver is an abstraction to the conventional driver. He tries to simplify the driver usage and sharing instance in your test runner. Driver Basics Pyppium driver has some facilities to use, and have some default parameters to simplify your tests. After start using the Pyppium remember to import it. from pyppium.driver import PyppiumDriver Connect to Appium Default Url If the Pyppium driver starts only, it will connect to \"http://localhost:4723/wd/hub\" . Pyppium ( caps ) Hint You can read more about appium capabilities in this Appium official documentation . Override Default Appium Url You can override the Appium default URL. Pyppium ( \"http://my-domain/wd/hub\" , caps ) Driver Instance After creating your driver instance you can access like that. Pyppium . instance () This instance () call return a webdriver . Remote . You can access attributes and functions as usual. Screenshot PyppiumDriver . instance () . get_screenshot_as_png () Checking Presence of Keyboard PyppiumDriver . instance () . is_keyboard_shown () Session # Return session PyppiumDriver . instance () . session # Return session_id PyppiumDriver . instance () . session_id Note All these commands are from webdriver . Remote , for more hot moves, see selenium official documentation . Getting Plataform Name You can show the running platform name simple like that. from pyppium import driver # Will return the name of the platform in lower case. # android or ios driver . platform_name () Checking Running Platform from pyppium import driver driver . is_android () # Or driver . is_ios () Quitting Driver Before killing the driver instance pyppium only check if the driver instance is not None . PyppiumDriver . quit () PyppiumDriver and Browserstack You can connect pyppium with BrowserStack like this. PyppiumDriver ( caps , user = \"meiko\" , keys = \"keys\" , use_browserstack = True ) Or you can use environment variables. export BROWSERSTACK_USERNAME=my-user export BROWSERSTACK_ACCESS_KEY=my-keys And you don't need to use user and keys parameters anymore. PyppiumDriver ( caps , use_browserstack = True ) Change between local appium and BrowserStack is easy, just changing the flag False . PyppiumDriver ( caps , user = \"meiko\" , keys = \"keys\" , use_browserstack = False ) Warning Remember! BrowserStack have specific capabilities, you can check this in Browserstack official documentation . Pytest Real Life Sample If your application has the same behaviours, you can easily run a test for android and ios with only one test. First, create your capabilities for android and ios. # Android appium capabilities caps_android = { \"platformName\" : \"Android\" , \"automationName\" : \"uiautomator2\" , \"deviceName\" : \"Android Emulator\" , \"appPackage\" : \"com.example.dummy\" , \"appActivity\" : \"MainActivity\" , \"newCommandTimeout\" : 0 , \"app\" : abspath ( \"tests/e2e/apps/app-debug.apk\" ) } # iOS appium capabilities caps_ios = { \"platformName\" : \"iOS\" , \"automationName\" : \"xcuitest\" , \"deviceName\" : \"iPhone 8\" , \"platformVersion\" : \"13.6\" , \"app\" : abspath ( \"tests/e2e/apps/dummy.app\" ) } Create your test case using parametrize and happy testing. @pytest . mark . parametrize ( \"capabilities\" , [ caps_ios , caps_android ]) def test_should_show_welcome_message ( capabilities ): PyppiumDriver ( capabilities ) # You screens stuff... PyppiumDriver . quit () Warning Remember to create your screen using pyppium fetcher .","title":"Pyppium Driver"},{"location":"pyppium-driver/#pyppium-driver","text":"The Pyppium driver is an abstraction to the conventional driver. He tries to simplify the driver usage and sharing instance in your test runner.","title":"Pyppium Driver"},{"location":"pyppium-driver/#driver-basics","text":"Pyppium driver has some facilities to use, and have some default parameters to simplify your tests. After start using the Pyppium remember to import it. from pyppium.driver import PyppiumDriver","title":"Driver Basics"},{"location":"pyppium-driver/#connect-to-appium-default-url","text":"If the Pyppium driver starts only, it will connect to \"http://localhost:4723/wd/hub\" . Pyppium ( caps ) Hint You can read more about appium capabilities in this Appium official documentation .","title":"Connect to Appium Default Url"},{"location":"pyppium-driver/#override-default-appium-url","text":"You can override the Appium default URL. Pyppium ( \"http://my-domain/wd/hub\" , caps )","title":"Override Default Appium Url"},{"location":"pyppium-driver/#driver-instance","text":"After creating your driver instance you can access like that. Pyppium . instance () This instance () call return a webdriver . Remote . You can access attributes and functions as usual.","title":"Driver Instance"},{"location":"pyppium-driver/#screenshot","text":"PyppiumDriver . instance () . get_screenshot_as_png ()","title":"Screenshot"},{"location":"pyppium-driver/#checking-presence-of-keyboard","text":"PyppiumDriver . instance () . is_keyboard_shown ()","title":"Checking Presence of Keyboard"},{"location":"pyppium-driver/#session","text":"# Return session PyppiumDriver . instance () . session # Return session_id PyppiumDriver . instance () . session_id Note All these commands are from webdriver . Remote , for more hot moves, see selenium official documentation .","title":"Session"},{"location":"pyppium-driver/#getting-plataform-name","text":"You can show the running platform name simple like that. from pyppium import driver # Will return the name of the platform in lower case. # android or ios driver . platform_name ()","title":"Getting Plataform Name"},{"location":"pyppium-driver/#checking-running-platform","text":"from pyppium import driver driver . is_android () # Or driver . is_ios ()","title":"Checking Running Platform"},{"location":"pyppium-driver/#quitting-driver","text":"Before killing the driver instance pyppium only check if the driver instance is not None . PyppiumDriver . quit ()","title":"Quitting Driver"},{"location":"pyppium-driver/#pyppiumdriver-and-browserstack","text":"You can connect pyppium with BrowserStack like this. PyppiumDriver ( caps , user = \"meiko\" , keys = \"keys\" , use_browserstack = True ) Or you can use environment variables. export BROWSERSTACK_USERNAME=my-user export BROWSERSTACK_ACCESS_KEY=my-keys And you don't need to use user and keys parameters anymore. PyppiumDriver ( caps , use_browserstack = True ) Change between local appium and BrowserStack is easy, just changing the flag False . PyppiumDriver ( caps , user = \"meiko\" , keys = \"keys\" , use_browserstack = False ) Warning Remember! BrowserStack have specific capabilities, you can check this in Browserstack official documentation .","title":"PyppiumDriver and Browserstack"},{"location":"pyppium-driver/#pytest-real-life-sample","text":"If your application has the same behaviours, you can easily run a test for android and ios with only one test. First, create your capabilities for android and ios. # Android appium capabilities caps_android = { \"platformName\" : \"Android\" , \"automationName\" : \"uiautomator2\" , \"deviceName\" : \"Android Emulator\" , \"appPackage\" : \"com.example.dummy\" , \"appActivity\" : \"MainActivity\" , \"newCommandTimeout\" : 0 , \"app\" : abspath ( \"tests/e2e/apps/app-debug.apk\" ) } # iOS appium capabilities caps_ios = { \"platformName\" : \"iOS\" , \"automationName\" : \"xcuitest\" , \"deviceName\" : \"iPhone 8\" , \"platformVersion\" : \"13.6\" , \"app\" : abspath ( \"tests/e2e/apps/dummy.app\" ) } Create your test case using parametrize and happy testing. @pytest . mark . parametrize ( \"capabilities\" , [ caps_ios , caps_android ]) def test_should_show_welcome_message ( capabilities ): PyppiumDriver ( capabilities ) # You screens stuff... PyppiumDriver . quit () Warning Remember to create your screen using pyppium fetcher .","title":"Pytest Real Life Sample"},{"location":"settings/","text":"Settings Pyppium has some global default settings and you can override all settings with a simple YAML file. Just add a file called pyppium.yaml to your root directory project like the sample below. driver : # driver main settings. timeout : 45 # fetch/fetches timeout. appium_url : \"http://localhost:3333/wd/hub\" # appium base URL. browserstack_url : \"@hub-cloud.browserstack.com/wd/hub:8080\" # brosewrstack base url. Or you can override only a specific key like timeout by example. driver : timeout : 45 Note Even with this settings file, you can override settings at runtime.","title":"Settings"},{"location":"settings/#settings","text":"Pyppium has some global default settings and you can override all settings with a simple YAML file. Just add a file called pyppium.yaml to your root directory project like the sample below. driver : # driver main settings. timeout : 45 # fetch/fetches timeout. appium_url : \"http://localhost:3333/wd/hub\" # appium base URL. browserstack_url : \"@hub-cloud.browserstack.com/wd/hub:8080\" # brosewrstack base url. Or you can override only a specific key like timeout by example. driver : timeout : 45 Note Even with this settings file, you can override settings at runtime.","title":"Settings"}]}